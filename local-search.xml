<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/project/2021/10/10/hello-world/"/>
    <url>/project/2021/10/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/project/2018/06/10/%E6%B5%8B%E8%AF%95/"/>
    <url>/project/2018/06/10/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>  前言：本文是用来记录自己学习数据结构与算法的笔记，写的不对的地方欢迎指正。</p><h1 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h1><p>表示一种变化趋势，并不是代码的具体执行时间。在公式中通常会忽略掉：常量，低阶，和系数。<br>复杂度分析<br>  用来分析所写算法的执行时间（时间复杂度）和占用的内存大小（空间复杂度）。<br>空间复杂度<br>  全称为渐进空间复杂度，用来表示算法的存储空间与数据规模之间的增长关系。<br>例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSMutableArray</span> *arr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithCapacity:n];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    [arr addObject:i];<br>&#125;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,arr);<br></code></pre></td></tr></table></figure><p>这段代码中只有第一行申请了一个大小为n的数组，所以这段代码的空间复杂度为O(n)。<br>常见的空间复杂度是O(1)，O(n)，O(n²)。<br>##时间复杂度<br>全称为渐进时间复杂度，用来表示代码执行时间随着数据规模增长的变化趋势。<br>公式：T(n)=O(f(n))<br>T(n):代码执行的时间；<br>f(n):表示每行代码执行的次数总和。<br>一般去分析一段代码的时间复杂度有几个方法：<br>1，只关注循环次数最多的一段代码<br>例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">- (void)exemple:(NSInteger)n<br>&#123;<br>    NSInteger tmp = <span class="hljs-number">0</span>;<span class="hljs-regexp">//</span><span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> (NSInteger i = <span class="hljs-number">0</span> ; i &lt; n; i ++) &#123;<span class="hljs-regexp">//</span><span class="hljs-number">2</span><br>        tmp = tmp + i;<span class="hljs-regexp">//</span><span class="hljs-number">3</span><br>    &#125;<span class="hljs-regexp">//</span><span class="hljs-number">4</span><br>    NSLog(@<span class="hljs-string">&quot;%ld&quot;</span>,tmp);<span class="hljs-regexp">//</span><span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码只有第3行执行了n次，其他行都只执行了常数量的次数，所以其时间复杂度为O(n)。<br>2，总复杂度等于量级最大的那段代码的复杂度</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)exemple:(<span class="hljs-built_in">NSInteger</span>)n<br>&#123;<br>    <span class="hljs-comment">//1</span><br>    <span class="hljs-built_in">NSInteger</span> tmp1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100000</span>; i ++) &#123;<br>        tmp1 = tmp1 + i;<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld&quot;</span>,tmp1);<br>    <br>    <br>    <span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">NSInteger</span> tmp2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span> ; i &lt; n; i ++) &#123;<br>        tmp2 = tmp2 + i;<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld&quot;</span>,tmp2);<br>    <br>    <span class="hljs-comment">//3</span><br>    <span class="hljs-built_in">NSInteger</span> tmp3 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span> ; i &lt; n; i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++) &#123;<br>            tmp3 = tmp3 + i * k;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld&quot;</span>,tmp3);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码1的时间复杂度为O(1)，2的复杂度为O(n)，3的复杂度为O(n²)，所以上述整段代码的时间复杂度为O(n²)。<br>3，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)exemple:(<span class="hljs-built_in">NSInteger</span>)n<br>&#123;<br>    <span class="hljs-built_in">NSInteger</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span> ; i &lt; n; i ++) &#123;<br>        tmp = [<span class="hljs-keyword">self</span> subExemple:i] + tmp;<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld&quot;</span>,tmp);<br>    <br>&#125;<br><br>- (<span class="hljs-built_in">NSInteger</span>)subExemple:(<span class="hljs-built_in">NSInteger</span>)n<br>&#123;<br>    <span class="hljs-built_in">NSInteger</span> subTmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span> ; i &lt; n; i ++) &#123;<br>        subTmp = subTmp + i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> subTmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>exemple的时间复杂度为O(n)，subExemple的时间复杂度为O(n)，所以这个代码的时间复杂度为O(n*n)=O(n²)。<br>下面看几个例子：<br>例1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)exemple:(<span class="hljs-built_in">NSInteger</span>)n<br>&#123;<br>    <span class="hljs-built_in">NSInteger</span> tmp = <span class="hljs-number">0</span>;<br>    tmp = tmp * n;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld&quot;</span>,tmp);<br>&#125;<br></code></pre></td></tr></table></figure><p>其时间复杂度也是Ο(1)，因为代码中不存在循环语句、递归语句。<br>例2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)exemple:(<span class="hljs-built_in">NSInteger</span>)n<br>&#123;<br>    <span class="hljs-built_in">NSInteger</span> tmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (tmp &lt;= n) &#123;<br>        tmp = tmp * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码的执行次数与tmp成某种函数关系。不难看出将所有的tmp值列出，其实就是一个等比数列（1，2，4，8…..）。所以时间复杂度为O(log2n)，又因为大O计数法可以忽略系数，所以最终结果为O(logn)。<br>例3：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)exemple:(<span class="hljs-built_in">NSInteger</span>)n m:(<span class="hljs-built_in">NSInteger</span>)m<br>&#123;<br>    <span class="hljs-built_in">NSInteger</span> tmp_n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span> ; i &lt; n; i ++) &#123;<br>        tmp_n = tmp_n + i;<br>    &#125;<br>    <br>    <span class="hljs-built_in">NSInteger</span> tmp_m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span> ; i &lt; n; i ++) &#123;<br>        tmp_m = tmp_m + i;<br>    &#125;<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%ld&quot;</span>,tmp_n + tmp_m);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们无法估计m和n的量级关系，所以m和n都不能忽略。那么时间复杂度为O(n+m)。<br>最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度<br>要搞明白这三个概念先看一个例子：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//在一个字符串数组里面查找一个字符串，找到就返回对应的下标，假设str一定能在数组中找到</span><br>- (NSInteger)exemple:(NSArray *)array <span class="hljs-built_in">str</span>:(NSString *)<span class="hljs-built_in">str</span><br>&#123;<br>    NSInteger <span class="hljs-keyword">index</span> = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (NSInteger i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-keyword">count</span>; i ++) &#123;<br>        NSString *tmp = array[i];<br>        <span class="hljs-keyword">if</span> ([tmp isEqualToString:<span class="hljs-built_in">str</span>]) &#123;<br>            <span class="hljs-keyword">index</span> = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最好情况时间复杂度<br>假设这个字符串就在数组的第一位，那么这个代码只需要执行一次就能获得结果，那么其时间复杂度就是O(1)。<br>最坏情况时间复杂度<br>如果这个字符串在数组的最后一位，那么他就需要执行array.count次也就是n次，所以他的时间复杂度是O(n)。<br>平均情况时间复杂度<br>不管是最好情况时间复杂度还是最坏情况时间复杂度都是极端的情况，在大多数的时候都不会发生，所以在大多数时候发生的情况就是平均情况时间复杂度。它的计算方法如下：<br>还是以上面的代码为例，str在数组0~array.count中间每个位置出现的概率都为1/n，那么可得<img src="https://upload-images.jianshu.io/upload_images/1636985-c3645661b15167b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="351583318375_.pic.jpg"><br>去掉系数和常数平均情况时间复杂度就是O(n)。<br>###均摊时间复杂度（参考：<a href="https://www.jianshu.com/p/b749a8afdfd2">https://www.jianshu.com/p/b749a8afdfd2</a>)<br>在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p><p>举例:有一个长度为n的数组,如果数组没满,就往里插入一个数,如果数组满了,就遍历求和。那么绝大多数情况下都是O(1),只有最后一次是O(n),均摊以后就是O(1)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
